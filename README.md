# Оптимізація взаємодії між RESTful API та SQL-базами даних


## Розглянемо декілька сценаріїв
### Перший сценарій: вибірка даних користувача з пов'язаними замовленнями.
Уявимо, що ви хочете отримати список усіх замовлень конкрентного користувача. 

Поглянемо на неоптимізований та оптимізований код.

* Неоптимізований Код: Спочатку видає дані про користувача, а потім окремим запитом видає дані про всі його замовлення. Це
  вимагає двох окремих запитів до бази даних, що може бути менш ефективним у термінах продуктивності (особливо з великим обсягом).

``` js 
app.get('/user/:id/with-orders', (req, res) => {
    let userId = req.params.id;

    // у нас тут будуть два окремих запити, не дуже ефективно
    db.query(`SELECT * FROM users WHERE user_id = ${userId}`, (err, userResult) => {
        if (err) throw err;

        db.query(`SELECT * FROM orders WHERE user_id = ${userId}`, (err, ordersResult) => {
            if (err) throw err;

            res.json({ user: userResult, orders: ordersResult });
        });
    });
});
```

* Оптимізований Код: Використовує один SQL запит з JOIN, щоб отримати всю необхідну інформацію. Це зменшує кількість запитів до 
бази даних та покращує час відгуку.

``` js 
app.get('/user/:id/with-orders', (req, res) => {
    let userId = req.params.id;

    let query = `
        SELECT users.*, orders.*
        FROM users
        LEFT JOIN orders ON users.user_id = orders.user_id
        WHERE users.user_id = ?`; 
    // використовуємо тут JOIN, більш ефективний підхід і зручний результат
    
    db.query(query, [userId], (err, result) => {
        if (err) throw err;
        res.json(result);
    });
});
```

У нашому оптимізованому сценарії, ми використовуємо SQL JOIN, який дозволяє об'єднувати дані з різних таблиць в одному запиті.
Використання JOIN є ключовим для зменшення кількості окремих запитів до бази даних, тим самим підвищуючи ефективність та 
скорочуючи час відповіді сервера. Наприклад, у нашому випадку, використання LEFT JOIN дозволяє одночасно отримати інформацію про 
користувача та його замовлення, тим самим забезпечуючи більш швидке та ефективне отримання повної інформації про користувача та 
його діяльність в одному запиті.

### Другий сценарій: агрегація даних про замовлення.
Уявімо, що нашому API потрібно надати статистику по замовленням користувачів. Ми хочемо отримати загальну кількість замовлень 
та загальну суму замовлень для кожного користувача.

* Неоптимізований Код: У неоптимізованому коді ми можемо отримувати дані для кожного користувача окремо, що призводить до великої кількості
запитів до бази даних.

``` js
app.get('/order-stats', (req, res) => {
    db.query('SELECT user_id FROM users', (err, users) => {
        if (err) throw err;

        let stats = [];
        
        users.forEach(user => { // тут у нас цикл і купа запитів, до того ж код некрасивий і не дуже читабельний
            db.query(`SELECT COUNT(*) as orderCount, SUM(amount) as totalAmount FROM orders WHERE user_id = ${user.user_id}`, (err, result) => {
                if (err) throw err;
                stats.push({ user: user.user_id, ...result[0] });
                if (stats.length === users.length) {
                    res.json(stats);
                }
            });
        });
    });
});
```

* Оптимізований Код: В оптимізованому варіанті ми можемо використовувати групування та агрегатні функції SQL для отримання всієї необхідної інформації 
одним запитом.

``` js
app.get('/order-stats', (req, res) => {
    // всього один запит, більш читабельно та приємно оку
    let query = `
        SELECT user_id, COUNT(*) as orderCount, SUM(amount) as totalAmount
        FROM orders
        GROUP BY user_id`;

    db.query(query, (err, result) => {
        if (err) throw err;
        res.json(result);
    });
});
```

В цьому сценарії оптимізація полягає у зменшенні кількості запитів до бази даних та використанні ефективних SQL операцій. Групування (GROUP BY)
та агрегатні функції (COUNT, SUM) дозволяють обробляти дані безпосередньо на рівні бази даних, що підвищує продуктивність та знижує навантаження на сервер.

Цей приклад показує, як оптимізація може бути застосована для підвищення ефективності обробки даних.

Ну і варто зазначити, що при збільшені кількості користувачів і замовлень неоптимізований приклад буде все більше неефективним.

Отже, оптимізований код не тільки ефективніше використовує ресурси бази даних, але й забезпечує кращий загальний досвід використання API,
оскільки знижує час на відповідь